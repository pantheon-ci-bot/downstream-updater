#!/bin/bash

#
# Default option values
#
PR_CREATOR=pantheon-upstream
FORK_OWNER=
REPO=pantheon-systems/drops-7
UPSTREAM_URL=http://git.drupal.org/project/drupal.git
UPDATE_REPO=
LABEL=shipit
BOT_NAME="Pantheon Upstream"
BOT_EMAIL="developers+pantheon-upstream@getpantheon.com"
TOOL_NAME="pantheon-systems/donwstream-updater"
MAINTAINER_EMAIL="greg+downstream-updater@pantheon.io"
VERSION_MAJOR="7"
VERSION_PATTERN=
REPO_BASE_BRANCH=master
TOKEN_CACHE="$HOME/.config/pantheon-upstream/github-token"
RELEASE_NODE=
FORCE_CLEANUP=false

debug=false
DO=
VERBOSE=false

#
# Return codes
#
ERROR_ALREADY_UP_TO_DATE=10

#
# Parse command line args
#
while [ $# -gt 0 ] ; do

  option="$1"
  shift

  case "$option" in
    -d|--debug)
      debug=true
      ;;

    -s|--simulate)
      DO=echo
      ;;

    -v|--verbose)
      VERBOSE=true
      ;;

    --force-cleanup)
      FORCE_CLEANUP=true
      ;;

    # --github-token TOKEN: specify the encoded token to use with the GitHub API.
    # See https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
    --github-token)
      ENCODED_TOKEN="$1"
      shift
      ;;

    # --token-cache FILE: specify the file where the encoded token should be cached
    --token-cache)
      TOKEN_CACHE="$1"
      shift
      ;;

    # --pr-creator USER: specify the GitHub user that will create the PR.
    # This is only needed if no TOKEN is provided.  The user will have
    # to enter their password to create the token.
    --pr-creator)
      PR_CREATOR="$1"
      shift
      ;;

    # --fork-owner USER: specify the owner of the forked repository to work
    # with (in case the user cannot commit to REPO)
    --fork-owner)
      FORK_OWNER="$1"
      shift
      ;;

    # --repo REPO: specify which repository we are updating.
    # This must be on GitHub; the name should be organization/project.
    --repo)
      REPO="$1"
      shift
      ;;

    # --upstream REPO: specify the upstream repository URL we are updating against.
    # This does not need to be on GitHub; any clone URL will work.
    --upstream-url)
      UPSTREAM_URL="$1"
      shift
      ;;

    # --update REPO: specify an "update" repo that is used to test the
    # repository being updated. This must be on GitHub; the name should
    # be organization/project.
    --update)
      UPDATE_REPO="$1"
      shift
      ;;

    # --label SHIPIT: specify the GitHub label identifying PRs to automatically
    # merge with the new release being tested.
    --label)
      LABEL="$1"
      shift
      ;;

    # The username to use in commit attributions for commits made by the bot
    --bot-name)
      BOT_NAME="$1"
      shift
      ;;

    # The email to use in commit attributions for commits made by the bot
    --bot-email)
      BOT_EMAIL="$1"
      shift
      ;;

    # The tool name to be used in the User Agent used in GitHub curl requests
    --tool-name)
      TOOL_NAME="$1"
      shift
      ;;

    # The email address to be used in the User Agent used in GitHub curl requests
    --maintainer-email)
      MAINTAINER_EMAIL="$1"
      shift
      ;;

    # The major version of Drupal (or eventually WordPress?) to update
    --version-major)
      VERSION_MAJOR="$1"
      shift
      ;;

    # The "version pattern" is the invariant part of the version that comes
    # after the major version, e.g. "0.0-beta" for Drupal 8.
    --version-pattern)
      VERSION_PATTERN="$1"
      shift
      ;;

    # --base master: the branch to start from
    --base)
      REPO_BASE_BRANCH="$1"
      shift
      ;;

    -*)
      echo "Unknown option $option"
      exit 1;
      ;;

    *)
      echo "Parameters are not used; '$option' is invalid."
      exit 1;
      ;;
  esac
done

# Given REPO in the form "pantheon-systems/drops-7", set:
#   REPO_URL: "git@github.com:pantheon-systems/drops-7"
#   REPO_OWNER: "pantheon-systems"
#   REPO_SHORT_NAME: "drops-7"
REPO_URL=git@github.com:${REPO}.git
REPO_OWNER=$(echo $REPO | sed -e 's#/[^/]*##')
REPO_SHORT_NAME=$(echo $REPO | sed -e 's#[^/]*/##')

# Given UPSTREAM_URL in the form "git@github.com:pressflow/7.git"
# or http://git.drupal.org/project/drupal.git, set:
#   UPSTREAM: pressflow/7
#   UPSTREAM_OWNER: pressflow
#   UPSTREAM_SHORT_NAME: 7
UPSTREAM=$(echo "$UPSTREAM_URL" | sed -e 's#git.drupal.org/project#git.drupal.org/drupal#' -e 's#\([^/]*/[^/]*\).git$#%%%\1#' -e 's/.*%%%//')
UPSTREAM_OWNER=$(echo $UPSTREAM | sed -e 's#/[^/]*##')
UPSTREAM_SHORT_NAME=$(echo $UPSTREAM | sed -e 's#[^/]*/##')

# If the user did not specify the url for the "updates"
# URL, then replace 'drops' with 'updates', and use that.
# TODO: Need to add a pattern for WordPress, once we support that.
if [ -z "$UPDATE_REPO" ]
then
  UPDATE_REPO="${REPO/drops/updates}"
  # If none of the patterns match, then the update repo URL will
  # be unchanged, and that would not be right.  Clear it, so the
  # updates step is skipped.
  if [ "$REPO" == "$UPDATE_REPO" ]
  then
    UPDATE_REPO=
  fi
fi

# If UPDATE_REPO is set, then also set related variables
if [ -n "$UPDATE_REPO" ]
then
  UPDATE_REPO_URL=git@github.com:${UPDATE_REPO}.git
  UPDATE_REPO_OWNER=$(echo $UPDATE_REPO | sed -e 's#/[^/]*##')
  UPDATE_REPO_SHORT_NAME=$(echo $UPDATE_REPO | sed -e 's#[^/]*/##')
fi

# If no fork owner was specified, then we will work directly
# from the main repository
if [ -z "$FORK_OWNER" ]
then
  FORK_OWNER="$REPO_OWNER"
fi

# The forked repo to clone.  This might be the same as REPO
FORKED_REPO_URL=git@github.com:${FORK_OWNER}/${REPO_SHORT_NAME}.git
FORKED_REPO=${FORK_OWNER}/${REPO_SHORT_NAME}

# Make an identifier from the bot name and email
BOT_IDENTIFIER="$BOT_NAME <$BOT_EMAIL>"

# Make a User-Agent string from the tool name and maintainer email address
UA="pantheon-systems/updater <greg+updater@pantheon.io>"

# Set a default version pattern for Drupal 8.
# This will need to be updated once d8 advances to
# a later phase (e.g. rc1).
if [ -z "$VERSION_PATTERN" ] && [ "$VERSION_MAJOR" == "8" ]
then
  VERSION_PATTERN="0.0-beta"
fi

# Set up a tmp directory to work in
TEMP_WORK=$(mktemp -d /tmp/update-script.XXX)

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   B A S H   F U N C T I O N S
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#
# Print a message if we are in VERBOSE mode
#
# Usage:
#
#    verbose_message "This is a message"
#
function verbose_message() {
  if $VERBOSE
  then
    echo "$1"
  fi
}

#
# Exit with a message if the previous function returned an error.
#
# Usage:
#
#   aborterr "Description of what went wrong"
#
function aborterr() {
  if [ $? != 0 ]
  then
    echo "$1" >&2
    exit 1
  fi
}

#
# Given a function parameter value containing flags, return a parsed
# argument string that can be passed in to curl to specify boolean
# argument values.
#
# Parameters:
#
#    ALL:     All of the available flags
#
#    TEST:    The function parameter value.  Contains 'flag' to
#             specify "flag": "true", or '!flag' to specify
#             "flag": "false".
#
# Usage:
#
#    parse_function_flags 'a b c d e f g' 'a !c f'
#
function parse_function_flags() {
  ALL="$(echo $1 | tr ',' ' ')"
  TEST=" $(echo $1 | tr ',' ' ') "

  for flag in $ALL
  do
    # Test to see if $TEST contains $flag by replacing " $flag " with
    # an empty string.  If the result is different than the unmodified
    # variable, then $TEST contains $flag.
    if [ "x${TEST/ $flag /}" == "x$TEST" ]
    then
      echo -n ", \"$flag\":\"true\""
    fi
    # Also check for !$flag, meaning "FALSE"
    flag='!'$flag
    if [ "x${TEST/ $flag /}" == "x$TEST" ]
    then
      echo -n ", \"$flag\":\"false\""
    fi
  done
}

#
# Check the result of the last operation, and either print progress or call aborterr
#
# Usage:
#
#   check "Something the script did" "Message to display if it did not work"
#
function check() {
  aborterr "$2"
  echo "$1"
}

#
# URL-encode a string
#
# Usage:
#
#    ENCODED=$(urlencode $DATA)
#
function urlencode() {
  local length="${#1}"
  for (( i = 0; i < length; i++ )); do
      local c="${1:i:1}"
      case $c in
          [a-zA-Z0-9.~_-]) printf "$c" ;;
          ' ') printf "+" ;;
          *) printf '%%%02X' "'$c"
      esac
  done
}

#
# Add a label to a repository
#
# Usage:
#
#   add_label_to_repo $REPO "label-name" "label-color"
#
function add_label_to_repo() {
  local TARGET_REPO="$1"
  local LABEL_NAME="$2"
  local LABEL_COLOR="$3"

  local ADD_LABEL_TO_REPO_FILE="$TEMP_WORK/add-label-to-repo.json"

  # Create the "automation" label if it does not already exist
  curl --user-agent "$UA" -H "Content-Type: application/json" -H "Authorization: token $ENCODED_TOKEN" --data '{ "name": "'"$LABEL_NAME"'", "color": "'"$LABEL_COLOR"'" }' "https://api.github.com/repos/$TARGET_REPO/labels" --output "$ADD_LABEL_TO_FILE" &>/dev/null
}

#
# Add a label to an issue (or PR)
#
# Usage:
#
#   add_label_to_repo $REPO $ISSUE_NUMBER "label-name" "label-color"
#
function add_label_to_issue() {
  local TARGET_REPO="$1"
  local ISSUE_NUMBER="$2"
  local LABEL_NAME="$3"
  local LABEL_COLOR="$4"

  local ADD_LABEL_TO_ISSUE_FILE="$TEMP_WORK/add-label-to-issue.json"

  # Add the specified label to the provided issue number
  curl --user-agent "$UA" -H "Content-Type: application/json" -H "Authorization: token $ENCODED_TOKEN" --data '[ "'"$LABEL_NAME"'" ]' "https://api.github.com/repos/$TARGET_REPO/issues/$ISSUE_NUMBER/labels" --output "$ADD_LABEL_TO_ISSUE_FILE" &>/dev/null
  if [ $? != 0 ]
  then
    # Label does not exist in the repository?  Create it first
    add_label_to_repo "$TARGET_REPO" "$LABEL_NAME" "$LABEL_COLOR"
    # Try to add the label again
    curl --user-agent "$UA" -H "Content-Type: application/json" -H "Authorization: token $ENCODED_TOKEN" --data '[ "'"$LABEL_NAME"'" ]' "https://api.github.com/repos/$TARGET_REPO/issues/$ISSUE_NUMBER/labels" --output "$ADD_LABEL_TO_ISSUE_FILE" &>/dev/null
  fi
}

#
# Add a label to an issue (or PR)
#
# Usage:
#
#   create_pull_request $REPO "Title" "Body" master pr-branch $OUTPUT_FILE
#
function create_pull_request() {
  local TARGET_REPO="$1"
  local TITLE="$2"
  local BODY="$3"
  local BASE="$4"
  local HEAD="$5"
  local OUTPUT_FILE="$6"

  echo curl --user-agent "$UA" -H "Content-Type: application/json" -H "Authorization: token $ENCODED_TOKEN" --data '{"title":"'"$TITLE"'", "body":"'"$BODY"'","head":"'"$HEAD"'","base":"'"$BASE"'"}' "https://api.github.com/repos/$TARGET_REPO/pulls"
  curl --user-agent "$UA" -H "Content-Type: application/json" -H "Authorization: token $ENCODED_TOKEN" --data '{"title":"'"$TITLE"'", "body":"'"$BODY"'","head":"'"$HEAD"'","base":"'"$BASE"'"}' "https://api.github.com/repos/$TARGET_REPO/pulls" --output "$OUTPUT_FILE" &>/dev/null
  check "Created new PR '$TITLE' on $TARGET_REPO" "Failed to create PR '$TITLE' on $TARGET_REPO"
}

#
# Find a pull request, given a title to search for
#
# Usage:
#
#    find_pull_request_by_title $REPO "Title" $OUTPUT_FILE
#
function find_pull_request_by_title() {
  local REPO="$1"
  local TITLE="$(urlencode "$2")"
  local OUTPUT_FILE="$3"

  curl --user-agent "$UA" "https://api.github.com/search/issues?q=$TITLE+type:pr+state:open+in:title+repo:$REPO" --output "$OUTPUT_FILE" &>/dev/null
}

#
# Find pull requests in a repo that have a certain label
#
# Usage:
#
#    find_pull_request_by_label $REPO "shipit" $OUTPUT_FILE
#
function find_pull_request_by_label() {
  local REPO="$1"
  local LABEL="$(urlencode "$2")"
  local OUTPUT_FILE="$3"

  curl --user-agent "$UA" "https://api.github.com/search/issues?q=+type:pr+state:open+label:$LABEL+repo:$REPO&sort=created&order=asc" --output "$OUTPUT_FILE" &>/dev/null
}

# GET /users/:username/repos
function list_repositories() {
  local TARGET_USER="$1"
  local OUTPUT_FILE="$2"

  curl --user-agent "$UA" "https://api.github.com/users/$TARGET_USER/repos" -H "Authorization: token $ENCODED_TOKEN" --output "$OUTPUT_FILE" &>/dev/null
  aborterr "Could not list repositories for $TARGET_USER"
}

#
# Create a repository owned by the authenticated user
#
# Usage:
#
#    create_repository 'test-repo-123' 'Description of repo', 'http://homepage.io' 'has_issues has_wiki has_downloads !auto_init' $OUTPUT_FILE
#
function create_repository() {
  local TARGET_REPO="$1"
  local DESCRIPTION="$2"
  local HOMEPAGE="$3"
  local FLAGS="$4"
  local OUTPUT_FILE="$5"

  ARGS="$(parse_function_flags "has_issues has_wiki has_downloads auto_init" "$FLAGS")"
  echo curl --user-agent "$UA" -H "Content-Type: application/json" -H "Authorization: token $ENCODED_TOKEN" --data '{"name":"'"$TARGET_REPO"'", "description":"'"$DESCRIPTION"'", "homepage":"'"$HOMEPAGE"'"'"$ARGS"'}' "https://api.github.com/user/repos" --output "$OUTPUT_FILE" &>/dev/null
  curl --user-agent "$UA" -H "Content-Type: application/json" -H "Authorization: token $ENCODED_TOKEN" --data '{"name":"'"$TARGET_REPO"'", "description":"'"$DESCRIPTION"'", "homepage":"'"$HOMEPAGE"'"'"$ARGS"'}' "https://api.github.com/user/repos" --output "$OUTPUT_FILE" &>/dev/null
  check "Created new PR '$TITLE' on $TARGET_REPO" "Failed to create PR '$TITLE' on $TARGET_REPO"
}

#
# Delete a repository.  Watch out!
#
# Usage:
#
#    delete_repository $REPO $OUTPUT_FILE
#
function delete_repository() {
  local TARGET_REPO="$1"
  local OUTPUT_FILE="$2"

  echo curl --user-agent "$UA" -H "Content-Type: application/json" -H "Authorization: token $ENCODED_TOKEN" -X DELETE "https://api.github.com/repos/$TARGET_REPO"
  curl --user-agent "$UA" -H "Content-Type: application/json" -H "Authorization: token $ENCODED_TOKEN" -X DELETE "https://api.github.com/repos/$TARGET_REPO" --output "$OUTPUT_FILE" &>/dev/null
}

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   V E R B O S E   S T A R T U P   M E S S A G E S
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

verbose_message "REPO is $REPO"
verbose_message "REPO_OWNER is $REPO_OWNER"
verbose_message "REPO_SHORT_NAME is $REPO_SHORT_NAME"

verbose_message "UPSTREAM is $UPSTREAM"
verbose_message "UPSTREAM_OWNER is $UPSTREAM_OWNER"
verbose_message "UPSTREAM_SHORT_NAME is $UPSTREAM_SHORT_NAME"

verbose_message "FORKED REPO URL is $FORKED_REPO_URL"
verbose_message "FORKED_REPO is $FORKED_REPO"
verbose_message "FORK_OWNER is $FORK_OWNER"

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   A U T H E N T I C A T E   W I T H   G I T H U B
#
#   If a github token was not provided, then create one using the
#   credentials passed via --pr-creator.
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# If no token was provided, then create one.
if [ -z "$ENCODED_TOKEN" ] && [ -f "$TOKEN_CACHE" ]
then
  ENCODED_TOKEN=$(cat $TOKEN_CACHE)
fi

if [ -z "$ENCODED_TOKEN" ]
then
  echo "--github-token not specified; creating a new token with account $PR_CREATOR.  This will require you to enter your password to grant this script permission to access your public repositories."
  # Authenticate with GitHub and create a token.  Note that this will prompt
  # the user for a password.
  AUTH_TOKEN_FILE="$TEMP_WORK/auth-token.txt"
  curl https://api.github.com/authorizations --user "$PR_CREATOR" --data '{"scopes":["public_repo","delete_repo"],"note":"Token used to create a PR in the create-update-pr script."}' --output "$AUTH_TOKEN_FILE"
  check "Authenticated with GitHub" "Could not authenticate with GitHub"

  cat $AUTH_TOKEN_FILE

  # Get the token data
  ENCODED_TOKEN="$(jq ".token" $AUTH_TOKEN_FILE | sed -e 's/"//g')"

  # Cache the OAuth token so that we do not need to prompt for a password
  # on successive requests.
  mkdir -p $(dirname "$TOKEN_CACHE")
  echo -n "$ENCODED_TOKEN" > "$TOKEN_CACHE"
  chmod 600 "$TOKEN_CACHE"
fi

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   C L E A N   U P
#
#   Get rid of junk repositories from prior test runs.
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

if $FORCE_CLEANUP
then

  PANTHEON_UPSTREAM_REPOSITORIES=/tmp/panuprepos.json
  DELETE_OUTPUT=/tmp/panupdelete.json
  list_repositories "$PR_CREATOR" "$PANTHEON_UPSTREAM_REPOSITORIES"
  #cat $PANTHEON_UPSTREAM_REPOSITORIES

  REPO_COUNT=$(jq ". | length" $PANTHEON_UPSTREAM_REPOSITORIES)
  #echo "There are $REPO_COUNT repositories"
  FIRST_REPO=$(jq ".[0].name" $PANTHEON_UPSTREAM_REPOSITORIES)
  #echo "The first repos name is $FIRST_REPO"
  FIRST_REPO_INFO=$(jq ".[0]" $PANTHEON_UPSTREAM_REPOSITORIES)
  #echo "The entire first repo record:"
  #echo $FIRST_REPO_INFO

  if [ -n "$REPO_COUNT" ]
  then
    for n in $(seq 0 $(($REPO_COUNT-1)))
    do
      repo_to_delete=$(jq ".[$n].name" $PANTHEON_UPSTREAM_REPOSITORIES | sed -e 's/"//g')
      echo "$n. $repo_to_delete"
      if [ "$repo_to_delete" != "$REPO" ] && [ "$repo_to_delete" != "$UPSTREAM" ]
      then
        case "$repo_to_delete" in
          downstream-project-*|upstream-project-*)
            delete_repository "$PR_CREATOR/$repo_to_delete" $DELETE_OUTPUT
            ;;
        esac
      fi
    done
  fi

fi

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   C L O N E   R E P O S I T O R Y   T O   U P D A T E
#
#   Create a local repository; clone it if it does not already exist,
#   or just update the local working copy if it does.
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

if [ ! -d "$REPO_SHORT_NAME" ] ; then
  echo "### Creating fresh clone of $REPO_SHORT_NAME"
  git clone $FORKED_REPO_URL $REPO_SHORT_NAME
  check "Checked out $FORKED_REPO_URL" "Failed to check out $FORKED_REPO_URL"
  cd $REPO_SHORT_NAME
  if [ "$REPO_URL" != "$FORKED_REPO_URL" ]
  then
    git remote add main $REPO_URL
    aborterr "Could not add remote 'main'"
  fi
  git checkout $REPO_BASE_BRANCH
  aborterr "Could not switch to $REPO_BASE_BRANCH"
else
  echo "### Updating $REPO_SHORT_NAME to HEAD of $REPO_BASE_BRANCH in github"
  cd $REPO_SHORT_NAME
  git checkout $REPO_BASE_BRANCH
  aborterr "Could not switch to $REPO_BASE_BRANCH"
  REMOTE=origin
  git remote show | grep main
  if [ $? == 0 ]
  then
    REMOTE=main
  fi
  git pull $REMOTE $REPO_BASE_BRANCH
  aborterr "Could not pull $REPO_BASE_BRANCH from remote $REMOTE of $REPO"
fi

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   F I N D   U P S T R E A M   R E L E A S E S
#
#   Look for new releases in the specified upstream repository.
#   Create a new branch to hold the changes, if it has not already
#   been made.
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#
# We are going to look for tags or a certain format.
#
# For Drupal 7:
#
#   7.38
#   7.37
#   7.36
#     ... etc
#
# For Drupal 8:
#
#   8.0.0-beta12
#   8.0.0-beta11
#   8.0.0-beta10
#     ... etc
#
# To find the next available tag, we first decide on what the invariant
# part of the tag should be, such as "7." for Drupal 7, or "8.0.0-beta"
# for Drupal 8.  We need to change this decision when there is a major
# change in the schema, e.g. when Drupal 8 moves to "8.0.0-rc1" or "8.1.0-alpha1";
# these newer releases will not be found or noticed until we make this
# update manually.
#
# Once we know the invariant part, we can find all tags that start with
# that string, remove that string from the beginning of each line, and then
# use `sort -n` to do a numeric sort, so that "12" is considered greater
# than "2".  This will give us the most recent available tag.
#
INVARIANT_PART="${VERSION_MAJOR}.${VERSION_PATTERN}"

# List all of the remote tags that match the invariant part of the tag,
# and then sort the remaining part of the string numerically.  The greatest
# of these becomes "$availableMinor".
availableMinor="$(git ls-remote --tags "$UPSTREAM_URL" | sed -e 's|refs/tags/||' | cut -f2 | grep "^$INVARIANT_PART[a-z0-9.-]*\$" | sed -e "s|$INVARIANT_PART||" | sort -n | tail -n 1)"
aborterr "Could not check for the most recent available version"
availableVersion="$INVARIANT_PART$availableMinor"

# Find the last commit hash that is part of the specified available version.
availableHash=$(git ls-remote --tags "$UPSTREAM_URL" | grep "refs/tags/$availableVersion\$" | cut -f1)
aborterr "Could not find the hash for the most recent available version"
# Create a working branch name, e.g. "update-7.38"
UPDATE_WORKING_BRANCH="update-$availableVersion"

# Set up variables that we will use to populate the PR we create
TITLE="Update to $UPSTREAM $availableVersion"
BODY=
UPDATE_PR_BODY=

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   M E R G E    U P S T R E A M    R E L E A S E
#
#   Merge the upstream release into the repository we are updating.
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

NEED_UPSTTREAM_MERGE=false

# If the most recent available version in the upstream repository already
# exists in the repository we are updating, then we do not need to merge
# the available upstream release in. Same thing if we already have a tag
# of the same name.

commithash=$(git log --grep="$availableVersion" --since=1.month --pretty=format:"%h")
hastag=$(git tag -l | grep $availableVersion)

if [ -n "$commithash" ] || [ -n "$hastag" ]
then
  echo "### $FORKED_REPO already has $availableVersion"
  for c in $commithash ; do echo && git log -1 $c ; done
  exit $ERROR_ALREADY_UP_TO_DATE
else
  hasBranch=$(git branch | grep $UPDATE_WORKING_BRANCH)
  if [ -n "$hasBranch" ]
  then
    echo "### $FORKED_REPO already has a branch $UPDATE_WORKING_BRANCH"
    git checkout $UPDATE_WORKING_BRANCH
  else
    echo "### $FORKED_REPO must be updated to $availableVersion"

    # Create our working branch
    $DO git checkout -B $UPDATE_WORKING_BRANCH
    aborterr "Could not create branch '$UPDATE_WORKING_BRANCH'"
    NEED_UPSTTREAM_MERGE=true
  fi
fi

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   A U T O - M E R G E   P U L L   R E Q U E S T S
#
#   Find pull requests that are labeled (e.g. "shipit") for automatic
#   inclusion in the next release.
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

PR_LIST_FILE="$TEMP_WORK/pulls.json"

#
# Search for PRs that are labeled for inclusion in this release.
# The label to search for should be in $LABEL.
#
if [ -n "$LABEL" ]
then
  # Search for PRs that are labeled with "$LABEL" (e.g. "shipit")
  find_pull_request_by_label "$REPO" "$LABEL" "$PR_LIST_FILE"

  # Skip the PR merge if the GitHub API fails us for some reason
  if [ -s "$PR_LIST_FILE" ]
  then
    # Find out how many results there are by counting '.items'
    PR_COUNT=$(jq ".items | length" $PR_LIST_FILE)

    # Get info for each PR
    NEED_PR_HEADER_IN_BODY=true
    if [ -n "$PR_COUNT" ]
    then
      for PR in $(seq 0 $((PR_COUNT-1)))
      do
        # Get the URL for the Nth PR
        PR_URL="$(jq ".items[$PR].pull_request.url" $PR_LIST_FILE | sed -e 's/"//g')"
        # Get the ID for the Nth PR
        PR_NUMBER="$(jq ".items[$PR].number" $PR_LIST_FILE)"

        # Download info about this one PR
        PR_INFO_FILE="$TEMP_WORK/pull-$PR_NUMBER.json"
        curl --user-agent "$UA" "$PR_URL" --output "$PR_INFO_FILE" &> /dev/null

        # If we cannot get any info on this PR, then we'll silently skip it.
        if [ -s "$PR_INFO_FILE" ]
        then

          # Get the name of the repo and branch the PR was created from.
          PR_BRANCH="$(jq ".head.ref" $PR_INFO_FILE | sed -e 's/"//g')"
          PR_REPO="$(jq ".head.repo.clone_url" $PR_INFO_FILE | sed -e 's/"//g')"
          PR_REPO_OWNER="$(jq ".head.repo.owner.login" $PR_INFO_FILE | sed -e 's/"//g')"

          # Get the name of the branch the PR was split off from
          PR_BASE_BRANCH="$(jq ".base.ref" $PR_INFO_FILE | sed -e 's/"//g')"

          # TODO: The PR base branch must be the same as the update
          # base branch.  Otherwise, we should skip this PR and somehow
          # notify that it was not automatically included
          # (write a comment into the PR?)

          PR_WORKING_BRANCH="${PR_REPO_OWNER}-${PR_BRANCH}"

          # Fetch some values to place in the commit comment.
          PR_GITHUB_URL="$(jq ".html_url" $PR_INFO_FILE | sed -e 's/"//g')"
          PR_TITLE="$(jq ".title" $PR_INFO_FILE | sed -e 's/"//g')"

          COMMIT_COMMENT_FILE="$TEMP_WORK/commit-comment-$PR_NUMBER.txt"

          cat << __EOF__ > "$COMMIT_COMMENT_FILE"
#$PR_NUMBER: $PR_TITLE [$LABEL]

Including pull request $PR_GITHUB_URL in branch $UPDATE_WORKING_BRANCH.
__EOF__

          # Check to see if there is already a commit on this branch that
          # contains "#$PR_NUMBER: ", and skip the merge if found.
          git checkout "$UPDATE_WORKING_BRANCH"
          commithash=$(git log --grep="#$PR_NUMBER:" --pretty=format:"%h")

          if [ -n "$commithash" ]
          then
            echo "Already merged #$PR_NUMBER: $PR_TITLE [$LABEL]"
          else

            echo

            $DO git checkout -b $PR_WORKING_BRANCH $REPO_BASE_BRANCH
            $DO git pull $PR_REPO $PR_BRANCH

            $DO git checkout "$UPDATE_WORKING_BRANCH"
            $DO git merge --squash "$PR_WORKING_BRANCH"
            $DO git commit --file="$COMMIT_COMMENT_FILE" --author="$BOT_IDENTIFIER"

            cat $COMMIT_COMMENT_FILE

            # TODO: After the $UPDATE_WORKING_BRANCH is merged, close all of these
            # pull requests, ideally with a comment indicating what happened.

          fi

          # Keep track of each PR that has been merged into this branch
          # in a comment in the BODY of the PR we will create below.
          if $NEED_PR_HEADER_IN_BODY
          then
            BODY="$BODY\\n\\nPull requests tagged [$LABEL] merged with this release:\\n"
            UPDATE_PR_BODY="$UPDATE_PR_BODY\\n\\nPull requests tagged [$LABEL] merged with this release:\\n"

            NEED_PR_HEADER_IN_BODY=false
          fi
          BODY="$BODY\\n#$PR_NUMBER: $PR_TITLE"
          UPDATE_PR_BODY="$UPDATE_PR_BODY\\n$REPO#$PR_NUMBER: $PR_TITLE"
        fi
      done
    fi
  fi
fi

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   M E R G E   U P S T R E A M   R E L E A S E
#
#   Merge the upstream release into the repository we are updating.
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

if $NEED_UPSTTREAM_MERGE
then
  # TODO:  Maybe we should make a temporary branch, and do a squash-merge here

  git checkout $UPDATE_WORKING_BRANCH
  aborterr "Could not switch to branch '$UPDATE_WORKING_BRANCH'"

  echo "### Pulling in latest release from $UPSTREAM_URL $availableVersion"
  $DO git pull "$UPSTREAM_URL" "$availableVersion"
  status=$(git status --porcelain . | grep '^UU')
  if [ -z "$status" ] ; then
    $DO git add -A .
    $DO git commit --author="$BOT_IDENTIFIER" -m "Update to $UPSTREAM_URL $availableVersion."
  fi
fi

# Push working branch back up to origin
$DO git push origin "$UPDATE_WORKING_BRANCH"
check "Pushed $UPDATE_WORKING_BRANCH back up to origin of $FORKED_REPO" "Could not push $UPDATE_WORKING_BRANCH to origin of $FORKED_REPO"

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   C R E A T E   B R A N C H   O N   U P D A T E S   R E P O
#
#   We do not have a .travis.yml or circle.yml in the repo that we
#   are updating, becasue we do not want this file to be inherited
#   by other repositories that use it as an upstream.
#
#   What we do instead is use a separate "update" repository that
#   uses composer to install and test the primary repository.
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

if [ -n "$UPDATE_REPO" ]
then

  # Clone the updates repo, or update it if there is already a
  # local working copy

  cd ..

  if [ ! -d "$UPDATE_REPO_SHORT_NAME" ] ; then
    echo "### Creating fresh clone of $UPDATE_REPO_SHORT_NAME"
    git clone $UPDATE_REPO_URL $UPDATE_REPO_SHORT_NAME
    check "Checked out $UPDATE_REPO_URL" "Failed to check out $UPDATE_REPO_URL"
    cd $UPDATE_REPO_SHORT_NAME
  else
    echo "### Updating $UPDATE_REPO_SHORT_NAME to HEAD of master in github"
    cd $UPDATE_REPO_SHORT_NAME
    git checkout master
    aborterr "Could not switch to master"
    git pull origin master
    aborterr "Could not pull master of $UPDATE_REPO_URL"
  fi

  # Make a branch to work on.  We'll use the same branch name that
  # we are using in the main REPO.

  git checkout "$UPDATE_WORKING_BRANCH"
  if [ $? != 0 ]
  then
    git checkout -b "$UPDATE_WORKING_BRANCH" master
  fi

  # Now we have a few changes to make to the composer.json file
  # of our updates repository.
  #
  # We want to make the following changes:
  #
  # "repositories": [
  # {
  #   "type": "package",
  #   "package": {
  #       "name": "pantheon-systems/drops-7", <-- (1) GIVE A TEMPORARY NAME
  #       "type": "drupal-core",
  #       "version": "7.37", <-- (2) UPDATE TO $availableVersion
  #       "source": {
  #           "url": "https://github.com/pantheon-systems/drops-7.git", <-- (3) Point at $FORKED_REPO_URL
  #           "type": "git",
  #           "reference": "master" <-- (4) Change to $UPDATE_WORKING_BRANCH (most important)
  #       },
  #       ...
  #    }
  #    ..
  # "require": {
  #      "pantheon-systems/drops-7": "7.*", <-- (5) MATCH TEMPORARY NAME USED ABOVE in "1"
  #
  # Our important assumption is that the $UPDATE_REPO provided must
  # be specifically prepared for for the $REPO being updated.  We therefore
  # are going to assume that the "name": entry always matches "/$REPO_SHORT_NAME".
  #
  # TODO: It might be kind of cool to write the entire "package" entry based
  # on info in the composer.json in the $REPO being updated, if said repo is
  # in packagist (in which case the $UPDATE_REPO does not need a "package"
  # entry in the "repositories" section).  For now, though, we will presume
  # that the updates repository has a package entry prepared and ready for
  # us to modify.
  #
  TEMPORARY_UPDATES_OWNER=pantheon-updates

  # (1) Replace "name": "pantheon-systems/drops-7" with our TEMPORARY_UPDATES_OWNER
  # There will only be one match for this particular pattern.
  sed -i '' -e 's#\("name": "\)\([^/]*\)\(/'$REPO_SHORT_NAME'"\)#\1'$TEMPORARY_UPDATES_OWNER'\3#' composer.json

  # (2) Replace "version": with our version
  # We must be careful to not change other similar patterns elsewhere in the file,
  # so we limit the scope of where our sed expression will operate
  sed -i '' -e '/name.*'$REPO_SHORT_NAME'/,/version/ s#\("version": "\)\([^"]*\)#\1'$availableVersion'#' composer.json

  # (3) Replace "url": with our url. Be careful to limit where we do our replacements.
  sed -i '' -e '/name.*'$REPO_SHORT_NAME'/,/url/ s#\("url": "\)\([^"]*\)#\1'$FORKED_REPO_URL'#' composer.json

  # (4) Replace "master" with our working branch name. Be careful to limit where we do our replacements.
  sed -i '' -e '/name.*'$REPO_SHORT_NAME'/,/reference/ s#master#'$UPDATE_WORKING_BRANCH'#' composer.json

  # (5) Replace "pantheon-systems/drops-7": with our TEMPORARY_UPDATES_OWNER.
  # There will only be one match for this particular pattern.
  sed -i '' -e 's#\("[^/]*\)\(/'$REPO_SHORT_NAME'": \)#"'$TEMPORARY_UPDATES_OWNER'\2#' composer.json

  # Run 'composer update' to pull in the branch we referenced in the changes above
  composer update
  check "Successfully ran 'composer update' on $UPDATE_REPO to point at $UPDATE_WORKING_BRANCH of $FORKED_REPO" "'composer update' failed on $UPDATE_REPO"

  # Commit to the new branch
  git add composer.json
  git add composer.lock
  git commit -m "Test $REPO $availableVersion"
  aborterr "Could not commit change to composer.json in $UPDATE_REPO"

  git push origin "$UPDATE_WORKING_BRANCH"
  check "Pushed $UPDATE_WORKING_BRANCH back up to origin of $UPDATE_REPO" "Could not push $UPDATE_WORKING_BRANCH to origin of $UPDATE_REPO"
fi

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   C R E A T E   P U L L   R E Q U E S T S
#
#   Make a pair of pull requests so that the new branch can be tested.
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Check to see if there is already a PR for this branch.

FIND_REPO_FILE="$TEMP_WORK/find-pr-in-repo.json"

find_pull_request_by_title "$REPO" "$TITLE" "$FIND_REPO_FILE"

NEW_PR_NUMBER="$(jq ".items[0].number" "$FIND_REPO_FILE" | sed -e 's/"//g')"

# If the PR was not found, then create it.
if [ -z "$NEW_PR_NUMBER" ] || [ "$NEW_PR_NUMBER" == "null" ]
then
  NEW_REPO_PR_INFO_FILE="$TEMP_WORK/new-pr.json"

  BODY="This PR was created by the create-update-pr script.\n\n$BODY"

  # Create the PR on REPO
  create_pull_request "$REPO" "$TITLE" "$BODY" "$REPO_BASE_BRANCH" "$UPDATE_WORKING_BRANCH" "$NEW_REPO_PR_INFO_FILE"

  # Get the PR number for the new PR
  NEW_PR_NUMBER="$(jq ".number" "$NEW_REPO_PR_INFO_FILE" | sed -e 's/"//g')"

  # Add an "automation" label to the update PR
  add_label_to_issue "$REPO" "$NEW_PR_NUMBER" "automation" "fad8c7"
fi

if [ -n "$UPDATE_REPO" ]
then

  FIND_UPDATE_REPO_FILE="$TEMP_WORK/find-pr-in-update-repo.json"

  find_pull_request_by_title "$UPDATE_REPO" "$TITLE" "$FIND_UPDATE_REPO_FILE"

  NEW_UPDATE_PR_NUMBER="$(jq ".items[0].number" "$FIND_UPDATE_REPO_FILE" | sed -e 's/"//g')"


  # If the PR was not found, then create it.
  if [ -z "$NEW_UPDATE_PR_NUMBER" ] || [ "$NEW_UPDATE_PR_NUMBER" == "null" ]
  then

    NEW_UPDATE_PR_INFO_FILE="$TEMP_WORK/new-update-pr.json"

    UPDATE_PR_BODY="This PR was created specifically for the purpose of testing $REPO#$NEW_PR_NUMBER\n\n$UPDATE_PR_BODY\n\n**IMPORTANT NOTE:** Once complete, this PR should be *closed*, not merged."

    # Create the PR on UPDATES
    create_pull_request "$UPDATE_REPO" "$TITLE" "$UPDATE_PR_BODY" "master" "$UPDATE_WORKING_BRANCH" "$NEW_UPDATE_PR_INFO_FILE"

    # Get the PR number for the new update PR
    NEW_UPDATE_PR_NUMBER="$(jq ".number" "$NEW_UPDATE_PR_INFO_FILE" | sed -e 's/"//g')"

    # Add an "automation" label to the update PR
    add_label_to_issue "$UPDATE_REPO" "$NEW_UPDATE_PR_NUMBER" "automation" "fad8c7"

  fi

fi

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#   C L E A N   U P
#
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# rm -rf "$TEMP_WORK"

